# DSA2-Projects
Projects, created in C, from Data Structures and Algorithms II

  i)        - project1_InvertedIndex -
      This project contains the source code for a 2-d vertex doucment index, that will compute the consine similarity between multiple documents. The program process through all the documents and tokenizes every word and puts them inside of a data structure that acts as a dictionary. Then, it processes this dictionary and determines a n x n matrix for cosine simularity, where n is the number of documents.
  
  ii)       - project2_CustomerQueue -
      This project contains the source code for a customer event queue. This program will take in user input for servers statistics that correspond to store averages such as, average arrivals, average served, etc., within a certain time period. Then goes on to calculate analytically expected results based on these values such as, average time in a queue, or wait and the average time it takes to server a customer. Then it processes realistically through this "day," simulating an average work day and then computers a simulation based result.
Finally, comparing the two results, both simulated and analytical, to determine accuracy.

  iii)      - project3_TSP -
      This project contains the source code for solving a version of the traveling sales person problem. This program will take in a number of cities and link them all together based on a predetermined text files containing the names of the cities that are linked together and their distances from one another. Then, it goes on to solve this problem. Two methods are used in solving this problem, one being the brute force method, or testing every possible path until the most optimal is determined, and a genetic-algorithm that acts as a form of "DNA splicing," mechanism in which the DNA is different permutations of possible paths. 
 
  iV)       - project4_BinPacking -
      This project continas the source code for solving the bin packing problem. This program will generate a nubmer of boxes and their sizes along with a number of bins and their sizes. Then, it goes on to determine, using different forms of algorithms, if all the boxes will fit into all the bins. Ultimately, trying to create an efficient packing mechanism, determining the best ordering of packing for the boxes to best utilize given space.
